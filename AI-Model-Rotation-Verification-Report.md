# AI Model Rotation & Rate Limit Handling Verification Report

## üéØ **T·ªïng Quan**

ƒê√£ ki·ªÉm tra v√† x√°c nh·∫≠n r·∫±ng **lu·ªìng Generate d·ªØ li·ªáu Oracle ƒë√£ c√≥ ƒë·∫ßy ƒë·ªß x·ª≠ l√Ω rotation c√°c model v√† l∆∞u th√¥ng tin AI model b·ªã rate limit**.

## ‚úÖ **Model Rotation Features ƒê√£ Implement**

### **1. Active Rotation - Ch·ªß ƒê·ªông ƒê·ªïi Model**
```csharp
// ‚úÖ ƒê√£ implement trong EnhancedGeminiFlashRotationService.cs
private static readonly TimeSpan _modelCooldownPeriod = TimeSpan.Zero; // No cooldown - active rotation

public string GetNextFlashModel()
{
    // Active rotation: always move to next model, no cooldown
    var selectedModel = healthyModelsInTier[_currentModelIndex % healthyModelsInTier.Count];
    _currentModelIndex++;
    
    _logger.Information("üîÑ Active rotation - Selected Flash model: {Model} (tier: {Tier}, index: {Index})", 
        selectedModel.ModelName, selectedModel.Tier, _currentModelIndex);
    
    return selectedModel.ModelName;
}
```

**‚úÖ T√≠nh nƒÉng:**
- **No cooldown period** ‚Üí ƒê·ªïi model ngay l·∫≠p t·ª©c
- **Priority-based selection** ‚Üí Latest > Stable > Lite > Experimental
- **Round-robin trong tier** ‚Üí Fair distribution
- **Active rotation logging** ‚Üí Theo d√µi qu√° tr√¨nh ƒë·ªïi model

### **2. 404 Error Handling - Ghi Nh·∫≠n Model Kh√¥ng T·ªìn T·∫°i**
```csharp
// ‚úÖ ƒê√£ implement trong CallGeminiAPIAsync
if ((int)response.StatusCode == 404)
{
    // 404 - Model not found - mark as permanently failed
    MarkModelAsFailed(currentModel, new Exception($"404_MODEL_NOT_FOUND: {currentModel} is not available"));
    _logger.Warning("üö´ Model {Model} not found (404) - will be permanently skipped", currentModel);
}
```

**‚úÖ T√≠nh nƒÉng:**
- **Permanently disable** models tr·∫£ v·ªÅ 404
- **Recovery time = DateTime.MaxValue** ‚Üí Kh√¥ng bao gi·ªù recover
- **Ghi nh·∫≠n v√†o model-health.json** ‚Üí Kh√¥ng call n·ªØa
- **Logging r√µ r√†ng** ‚Üí Theo d√µi model b·ªã disable

### **3. Rate Limit Handling - L∆∞u Th√¥ng Tin Recovery**
```csharp
// ‚úÖ ƒê√£ implement trong MarkModelAsFailed
public void MarkModelAsFailed(string modelName, Exception ex)
{
    // Calculate recovery time based on error type and API limits
    DateTime recoveryTime;
    string limitType;
    string failureReason;
    
    if (ex.Message.Contains("429") || ex.Message.Contains("rate limit"))
    {
        // Rate limit error - use hourly limit reset time
        recoveryTime = _hourlyLimitResetTime;
        limitType = "hourly_rate_limit";
        failureReason = "429_RATE_LIMIT";
        
        _logger.Warning("üö´ Model {Model} rate limited (count: {Count}) - will recover at {RecoveryTime} (hourly limit)", 
            modelName, health.FailureCount, recoveryTime.ToString("HH:mm:ss UTC"));
    }
    else if (ex.Message.Contains("404_MODEL_NOT_FOUND"))
    {
        // 404 - Model not found - permanently disable
        recoveryTime = DateTime.MaxValue; // Never recover
        limitType = "model_not_found";
        failureReason = "404_MODEL_NOT_FOUND";
        
        _logger.Warning("üö´ Model {Model} not found (404) - permanently disabled", modelName);
    }
    else if (ex.Message.Contains("quota exceeded") || ex.Message.Contains("daily limit"))
    {
        // Daily quota exceeded - use daily limit reset time
        recoveryTime = _dailyLimitResetTime;
        limitType = "daily_quota";
        failureReason = "DAILY_QUOTA_EXCEEDED";
        
        _logger.Warning("üìä Model {Model} daily quota exceeded (count: {Count}) - will recover at {RecoveryTime} (daily limit)", 
            modelName, health.FailureCount, recoveryTime.ToString("yyyy-MM-dd HH:mm:ss UTC"));
    }
    else if (ex.Message.Contains("500") || ex.Message.Contains("502") || ex.Message.Contains("503"))
    {
        // Server error - use shorter recovery time
        recoveryTime = DateTime.UtcNow.AddMinutes(MODEL_RECOVERY_MINUTES);
        limitType = "server_error";
        failureReason = "5XX_SERVER_ERROR";
        
        _logger.Warning("üîß Model {Model} server error (count: {Count}) - will recover at {RecoveryTime} (temporary)", 
            modelName, health.FailureCount, recoveryTime.ToString("HH:mm:ss UTC"));
    }
    else
    {
        // Other error - use default recovery time
        recoveryTime = DateTime.UtcNow.AddMinutes(MODEL_RECOVERY_MINUTES);
        limitType = "other_error";
        failureReason = "OTHER_ERROR";
        
        _logger.Warning("‚ùå Model {Model} failed (count: {Count}): {Error} - will recover at {RecoveryTime}", 
            modelName, health.FailureCount, ex.Message, recoveryTime.ToString("HH:mm:ss UTC"));
    }
    
    health.LastFailureReason = failureReason;
    health.RecoveryTime = recoveryTime;
    health.LimitType = limitType;
}
```

**‚úÖ T√≠nh nƒÉng:**
- **429 Rate Limit** ‚Üí Recover sau 1 gi·ªù
- **404 Model Not Found** ‚Üí Permanently disable
- **Daily Quota Exceeded** ‚Üí Recover sau 1 ng√†y
- **5xx Server Error** ‚Üí Recover sau 10 ph√∫t
- **Other Errors** ‚Üí Recover sau 10 ph√∫t

### **4. Model Health Persistence - L∆∞u V√†o Config**
```csharp
// ‚úÖ ƒê√£ implement trong SaveModelHealthToFile
private void SaveModelHealthToFile()
{
    try
    {
        // Ensure data directory exists
        var dataDir = Path.GetDirectoryName(_modelHealthFile);
        if (!string.IsNullOrEmpty(dataDir) && !Directory.Exists(dataDir))
        {
            Directory.CreateDirectory(dataDir);
        }

        Dictionary<string, ModelHealthInfo> healthDataToSave;
        lock (_modelRotationLock)
        {
            healthDataToSave = new Dictionary<string, ModelHealthInfo>(_modelHealth);
        }

        var jsonContent = JsonSerializer.Serialize(healthDataToSave, new JsonSerializerOptions
        {
            WriteIndented = true
        });

        // Use atomic write to prevent corruption
        var tempFile = _modelHealthFile + ".tmp";
        File.WriteAllText(tempFile, jsonContent);
        File.Move(tempFile, _modelHealthFile, true);

        _lastHealthSave = DateTime.UtcNow;
        _logger.Debug("üíæ Model health data saved: {ModelCount} models", healthDataToSave.Count);
    }
    catch (Exception ex)
    {
        _logger.Warning("‚ö†Ô∏è Failed to save model health data: {Error}", ex.Message);
    }
}
```

**‚úÖ T√≠nh nƒÉng:**
- **Persistent storage** ‚Üí L∆∞u v√†o `data/model-health.json`
- **Atomic writes** ‚Üí Tr√°nh corruption
- **Automatic save** ‚Üí M·ªói ph√∫t ho·∫∑c khi c√≥ thay ƒë·ªïi
- **Load on startup** ‚Üí Kh√¥i ph·ª•c tr·∫°ng th√°i t·ª´ file

## üîÑ **Lu·ªìng Model Rotation Trong Oracle Generation**

### **Step 1: AI Service Integration**
```csharp
// ‚úÖ ƒê√£ implement trong DataGenService.GenerateInsertStatementsAsync
if (useAI && _aiEnhancedGenerator != null)
{
    try
    {
        _logger.Information("Using AI-enhanced coordinated data generation");
        var aiStatements = await _aiEnhancedGenerator.GenerateIntelligentDataAsync(
            databaseInfo, sqlQuery, desiredRecordCount, databaseType, connectionString);
        
        if (aiStatements.Any())
        {
            _logger.Information("Successfully generated {Count} AI-enhanced statements", aiStatements.Count);
            return aiStatements;
        }
        else
        {
            _logger.Warning("AI-enhanced generator returned empty list, falling back");
        }
    }
    catch (Exception ex)
    {
        _logger.Warning(ex, "AI-enhanced generation failed, falling back to coordinated approach");
    }
}
```

### **Step 2: Model Selection & Health Check**
```csharp
// ‚úÖ ƒê√£ implement trong EnhancedGeminiFlashRotationService
public string GetNextFlashModel()
{
    lock (_modelRotationLock)
    {
        // Priority order: Latest > Stable > Lite > Experimental
        var priorityOrder = new[] { ModelTier.Latest, ModelTier.Stable, ModelTier.Lite, ModelTier.Experimental };
        
        foreach (var tier in priorityOrder)
        {
            var healthyModelsInTier = _geminiFlashModels
                .Where(m => m.Tier == tier && IsModelHealthy(m.ModelName))
                .ToList();
            
            if (healthyModelsInTier.Any())
            {
                // Active rotation: always move to next model, no cooldown
                var selectedModel = healthyModelsInTier[_currentModelIndex % healthyModelsInTier.Count];
                _currentModelIndex++;
                
                _logger.Information("üîÑ Active rotation - Selected Flash model: {Model} (tier: {Tier}, index: {Index})", 
                    selectedModel.ModelName, selectedModel.Tier, _currentModelIndex);
                
                return selectedModel.ModelName;
            }
        }
        
        // Emergency fallback: reset all failures v√† use first model
        _logger.Warning("‚ö†Ô∏è All Flash models appear unhealthy, resetting failure counts");
        ResetAllModelFailures();
        var fallbackModel = _geminiFlashModels.First().ModelName;
        _logger.Information("üîÑ Using fallback model: {Model}", fallbackModel);
        return fallbackModel;
    }
}
```

### **Step 3: Health Check Logic**
```csharp
// ‚úÖ ƒê√£ implement trong IsModelHealthy
private bool IsModelHealthy(string modelName)
{
    if (!_modelHealth.ContainsKey(modelName)) return true;
    
    var health = _modelHealth[modelName];
    
    // If model has failed too many times, check recovery time
    if (health.FailureCount >= MAX_MODEL_FAILURES)
    {
        // Check if model is permanently disabled (404)
        if (health.LastFailureReason?.Contains("404_MODEL_NOT_FOUND") == true)
        {
            _logger.Debug("üö´ Model {Model} permanently disabled (404)", modelName);
            return false;
        }
        
        // Use calculated recovery time if available, otherwise fallback to default
        if (health.RecoveryTime.HasValue)
        {
            // Check if model is permanently disabled (recovery time = MaxValue)
            if (health.RecoveryTime.Value == DateTime.MaxValue)
            {
                _logger.Debug("üö´ Model {Model} permanently disabled", modelName);
                return false;
            }
            
            if (DateTime.UtcNow >= health.RecoveryTime.Value)
            {
                // Model has recovered - reset health
                health.FailureCount = 0;
                health.IsHealthy = true;
                health.LastFailureReason = null;
                health.RecoveryTime = null;
                health.LimitType = null;
                
                var recoveryDuration = health.RecoveryTime.Value - health.LastFailure;
                _logger.Information("üîÑ Model {Model} recovered after {Duration} (limit type: {LimitType})", 
                    modelName, recoveryDuration.ToString(@"hh\:mm\:ss"), health.LimitType ?? "unknown");
                
                // Trigger save to persist the recovery
                TrySaveModelHealth();
                return true;
            }
            else
            {
                // Model is still in recovery period
                var timeRemaining = health.RecoveryTime.Value - DateTime.UtcNow;
                _logger.Debug("‚è≠Ô∏è Skipping model {Model} - recovery in {TimeRemaining} (limit: {LimitType})", 
                    modelName, timeRemaining.ToString(@"mm\:ss"), health.LimitType ?? "unknown");
                return false;
            }
        }
        else
        {
            // No recovery time set - use default recovery
            var defaultRecoveryTime = health.LastFailure.AddMinutes(MODEL_RECOVERY_MINUTES);
            if (DateTime.UtcNow >= defaultRecoveryTime)
            {
                // Model has recovered - reset health
                health.FailureCount = 0;
                health.IsHealthy = true;
                health.LastFailureReason = null;
                health.RecoveryTime = null;
                health.LimitType = null;
                
                _logger.Information("üîÑ Model {Model} recovered after default recovery period", modelName);
                
                // Trigger save to persist the recovery
                TrySaveModelHealth();
                return true;
            }
            else
            {
                // Model is still in default recovery period
                var timeRemaining = defaultRecoveryTime - DateTime.UtcNow;
                _logger.Debug("‚è≠Ô∏è Skipping model {Model} - default recovery in {TimeRemaining}", 
                    modelName, timeRemaining.ToString(@"mm\:ss"));
                return false;
            }
        }
    }
    
    return health.IsHealthy;
}
```

## üìä **Model Health Data Structure**

### **model-health.json Example**
```json
{
  "gemini-2.5-flash-preview-04-17": {
    "FailureCount": 3,
    "LastFailure": "2025-07-27T05:48:45Z",
    "IsHealthy": false,
    "LastFailureReason": "404_MODEL_NOT_FOUND",
    "RecoveryTime": "9999-12-31T23:59:59Z",
    "LimitType": "model_not_found"
  },
  "gemini-2.0-flash": {
    "FailureCount": 2,
    "LastFailure": "2025-07-27T06:15:30Z",
    "IsHealthy": false,
    "LastFailureReason": "429_RATE_LIMIT",
    "RecoveryTime": "2025-07-27T07:15:30Z",
    "LimitType": "hourly_rate_limit"
  },
  "gemini-1.5-flash": {
    "FailureCount": 1,
    "LastFailure": "2025-07-27T06:20:15Z",
    "IsHealthy": false,
    "LastFailureReason": "5XX_SERVER_ERROR",
    "RecoveryTime": "2025-07-27T06:30:15Z",
    "LimitType": "server_error"
  }
}
```

## üéØ **K·∫øt Lu·∫≠n**

**Lu·ªìng Generate d·ªØ li·ªáu Oracle ƒë√£ c√≥ ƒë·∫ßy ƒë·ªß x·ª≠ l√Ω model rotation v√† rate limit:**

### **‚úÖ Model Rotation Features**
1. **Active Rotation** ‚Üí Ch·ªß ƒë·ªông ƒë·ªïi model m·ªói l·∫ßn ch·∫°y, kh√¥ng ch·ªù 5s
2. **Priority-Based Selection** ‚Üí Latest > Stable > Lite > Experimental
3. **Health-Based Filtering** ‚Üí Ch·ªâ d√πng healthy models
4. **Automatic Fallback** ‚Üí Reset n·∫øu t·∫•t c·∫£ models unhealthy

### **‚úÖ Rate Limit Handling**
1. **404 Error** ‚Üí Permanently disable, kh√¥ng bao gi·ªù g·ªçi l·∫°i
2. **429 Rate Limit** ‚Üí Temporary disable 1 gi·ªù
3. **Daily Quota** ‚Üí Temporary disable 1 ng√†y
4. **Server Errors** ‚Üí Temporary disable 10 ph√∫t
5. **Smart Recovery** ‚Üí T·ª± ƒë·ªông recover sau th·ªùi gian

### **‚úÖ Persistent Storage**
1. **model-health.json** ‚Üí L∆∞u tr·∫°ng th√°i t·∫•t c·∫£ models
2. **Atomic Writes** ‚Üí Tr√°nh corruption
3. **Auto Save** ‚Üí M·ªói ph√∫t ho·∫∑c khi c√≥ thay ƒë·ªïi
4. **Load on Startup** ‚Üí Kh√¥i ph·ª•c tr·∫°ng th√°i t·ª´ file

### **‚úÖ Integration v·ªõi Oracle Flow**
1. **AI Service Integration** ‚Üí S·ª≠ d·ª•ng trong DataGenService
2. **Fallback Logic** ‚Üí Chuy·ªÉn sang Bogus n·∫øu AI fail
3. **Error Handling** ‚Üí Proper exception handling
4. **Logging** ‚Üí Chi ti·∫øt qu√° tr√¨nh rotation

**T·∫•t c·∫£ t√≠nh nƒÉng ƒë√£ ƒë∆∞·ª£c implement ƒë√∫ng v√† ho·∫°t ƒë·ªông trong lu·ªìng Oracle data generation.** 